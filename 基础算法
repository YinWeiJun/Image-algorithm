1. 二值化
=========
    所谓二值化简单一点讲，就是将图像划分成黑和白，通过设定一个标准如果大于这个标准就设为白，如果小于这个标准，就设为黑，而这个标准，就叫做阈值。
                                                                ---------------------------------------------
    f(i, j)表示图像中的像素在(i,j)位置上的灰度值，二值化处理可按下式进行：
            
                     |--> 1  f(i,j) >= t
            f(i,j) = |
                     |--> 0  f(i,j) <  t
                     
    具体算法中，灰度值为0~255，0表示黑色，255表示白色。由于图像一般由R，G，B三种颜色组成。所以只有R,G,B三个颜色层的灰度值都小于阈值t时，f(i,j)
    才等于0，否则等于255.

2. 灰度化
=========
    灰度化有很多种处理方法，有分量法、最大值法、平均值法以及加权平均值法。
    
    (1) 分量法
    
        将彩色图像中的三分量的亮度作为三个灰度图像的灰度值，可根据应用需要选取一种灰度图像。

        f1(i,j)=R(i,j)  f2(i,j)=G(i,j)  f3(i,j)=B(i,j)

        其中fk(i,j)(k=1,2,3)为转换后的灰度图像在（i,j）处的灰度值。
        
    (2) 最大值法
    
        将彩色图像中的三分量亮度的最大值作为灰度图的灰度值。

        f(i,j)=max(R(i,j),G(i,j),B(i,j))
        
    (3) 平均值法
        
        将彩色图像中的三分量亮度求平均得到一个灰度图。

        f(i,j)=(R(i,j)+G(i,j)+B(i,j))/3
        
    (4) 加权平均法
    
        根据重要性及其它指标，将三个分量以不同的权值进行加权平均。由于人眼对绿色的敏感最高，对蓝色敏感最低，因此，按下式对RGB三分量进行加权
        
        平均能得到较合理的灰度图像。

        f(i,j)=0.30*R(i,j)+0.59*G(i,j)+0.11*B(i,j))
    
3. 图像放大算法
==============
    图像放大有许多算法，其关键在于对未知像素使用何种插值方式。以下我们将具体分析几种常见的算法，然后从放大后的图像是否存在色彩失真，图像的细
    
    节是否得到较好的保存，放大过程所需时间是否分配合理等多方面来比较它们的优劣。
    
    当把一个小图像放大的时候，比如放大400%，我们可以首先依据原来的相邻4个像素点的色彩值，按照放大倍数找到新的ABCD像素点的位置并进行对应的填
    
    充，但是它们之间存在的大量的像素点，比如p点的色彩值却是不可知的，需要进行估算。
    
    ---------             ---------------------------
    | A | B |                | A |   |   |   | B |
    ---------  放大4倍     ---------------------------
    | C | D |                |   |   |   |   |   |
    ---------              ---------------------------
                             |   |   |   |   |   |
                           ---------------------------
                             |   |   |   | P |   |
                           ---------------------------
                             | C |   |   |   | D |
                           ---------------------------
                           
    (1) 最临近点插值法(Nearest Neighbor)
    
        最邻近点插值算法是最简单也是速度最快的一种算法，其做法是將放大后未知的像素点P，將其位置换算到原始影像上，与原始的邻近的4周像素点
        
        A,B,C,D做比较，令P点的像素值等于最靠近的邻近点像素值即可。如上图中的P点，由于最接近D点，所以就直接取P=D。这种方法会带来明显的失
        
        真。在A,B中点处的像素值会突然出现一个跳跃，这就是出现马赛克和锯齿等明显走样的原因。最临近插值法唯一的优点就是速度快。
                         
    (2) 双线性插值算法(Bilinear Interpolation)
        
        其做法是將放大后未知的像素点P，將其位置换算到原始影像上，计算的四個像素点A,B,C,D对P点的影响(越靠近P点取值越大，表明影响也越大)，
        
        其示意图如下。
        
        ---------------------------
        | A |   |   | e | B |
        ---------------------------           先由A,B计算出e, C,D计算出f, 最后根据e,f计算P
        |   |   |   |   |   |
        ---------------------------
        |   |   |   |   |   |
        ---------------------------
        |   |   |   | P |   |
        ---------------------------
        | C |   |   | f | D |
        ---------------------------
    
    (3) 双立方插值算法(Bicubic Interpolation)
    
        双立方插值算法与双线性插值算法类似，对于放大后未知的像素点P，将对其影响的范围扩大到邻近的16个像素点，依据对P点的远近影响进行插值计算，
        
        因P点的像素值信息来自16个邻近点，所以可得到较细致的影像，不过速度比较慢。
    
4. 模糊化
=========
    所谓的模糊化，就是将各个像素的相邻的像素的各个分量的值相加，然后除以2就可以实现对图像的模糊处理。
    
    
    
    
    
